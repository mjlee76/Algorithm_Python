- 다익스트라 : 한 노드에서 다른 모든 노드까지 가는데 최소비용
- 간선을 저장하는 방법 : 인접 리스트 + 거리 배열
    - 거리배열 : 각 노드까지의 거리 저장 배열
    - 거리 배열 초기값을 무한대로 설정
        - [INF, INF, INF, INF, INF]
    - 힙 시작점 추가(힙:최소값 최대값을 빠르게 찾는 자료구조)
        - (0, 1) #(비용, 시작노드)
        - [0, INF, INF, INF, INF]
    - 힙에서 현재 노드 빼면서, 간선 통할때 거리 더 짧아진다면
        - 거리 갱신 및 힙에 추가
        - (0, 1)#삭제, (2, 2) (3, 3)#추가
        - [0, 2, 3, INF, INF]


<핵심 코드>

dist[k] = 0                # 거리 배열 초기화 
heapq.heappush(heap, (0, K))

while heap:                # 힙이 빌때까지 반복
    w, v = heapq.heappop(heap)
    if w != dist[v]: # 거리배열의 값과 w(비용)이 다르면 건너뜀
        continue
    for nw, nv in edge[v]:
        # 현재 거리배열의 값(nv까지 값)이 
        # 새로운 값(v까지의 비용+새로추가될nv까지 비용)
        # 보다 더 크면 작은걸로 갱신
        if dist[nv] > dist[v] + nw: 
            dist[nv] = dist[v] + nw
            heapq.heappush(heap,(dist[nv], nv))

<아이디어>

- 한점에서 다른 모든 점으로의 최단경로 > 다익스트라 사용
- 모든 점 거리 초기값 무한대로 설정
- 시작점 거리 0 설정 및 힙에 추가
- 힙에서 하나씩 빼면서 수행할 것
    - 현재 거리가 새로운 간선 거칠때보다 크다면 갱신
    - 새로운 거리 힙에 추가


<시간복잡도>

- heap 의 삽입과 삭제 : O(lgN) #외우기
- 다익스트라 시간복잡도 : ElgE # E: 최대 간선 갯수
    - E = V^2
    - ElgE == ElgV^2 == 2ElgV == ElgV
    - 따라서 다익스트라 시간복잡도 : O(ElgV)


<변수>

- 다익스트라 사용 힙 : (비용(int), 다음노드(int))[]
- 거리 배열 : int[]
- 간선, 인접 리스트 : (비용(int), 다음노드(int))[]


@@@ TIP @@@

- 다익스트라 코드는 그냥 외우기!
- 코드가 복잡하므로 연습 필요
- 중요한건, 해당 문제가 다익스트라인지 알아내기만 하면
   딱히 응용없이 그대로 풀수 있음
   - 한점에서 다른점으로 가는 최소비용